## タスク生成の戦略

### 依存関係の分析
要件間の暗黙の依存関係を特定し、実装順序を決定する:
- **型・インターフェース定義** → それを使う実装
- **基盤機能** → 統合・拡張機能
- **内部ロジック** → 外部インターフェース（CLI, API, UI）
- **コア実装** → テスト

### 段階的生成
全要件を一度にカバーする必要はない。確実に実装できる基盤部分から生成する:
- 初回: 型定義、データモデル、コア機能など土台となる要件
- 後続イテレーション: 残りの要件を順次カバー

依存関係が不明確な要件や、既存コードの調査が必要な要件は、後続イテレーションに回してよい。

### タスク粒度
- 1タスクの作業量は「1つの明確な成果物」を目安とする
- 大きすぎる要件は複数タスクに分割する
- 小さい要件は関連するものをまとめてもよい

## タスク設計の原則

1. **単一責任**: 1タスク = 1つの明確な成果物
2. **検証可能**: 各タスクに機械的に確認可能な validation を定義
3. **依存関係の明示**: depends_on で順序を制御
4. **自己完結**: 各タスクの instruction は単独で実行可能な情報を含む
5. **セットアップと作業の分離**: ツールのインストール等のセットアップは、それを使う作業と同一タスクにしない
6. **カバレッジ追跡**: 各 validation で対応する acceptance_criteria ID を covers で明示（後続イテレーションで残りをカバー可能）

## 出力フォーマット

```yaml
tasks:
  - id: task_1
    name: {タスク名}
    depends_on: []
    instruction: |
      {具体的な作業指示}

      ## 変更対象
      - `{path/to/file}`: {変更内容}

      ## 関連パス
      - `{path/to/related}`: {役割・関係性}
    validation:
      - criterion: "{検証項目1}"
        covers: [req_id.1, req_id.2]
      - criterion: "{検証項目2}"
        covers: [req_id.3]
```
